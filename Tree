1.Segment Tree
struct SegmentTreeNode {
    int s, e, sum;
    SegmentTreeNode* left; 
    SegmentTreeNode* right;
    SegmentTreeNode(int _s, int _e) : s(_s), e(_e), sum(0), left(NULL), right(NULL) {}
};

class SegmentTree {
public:
    SegmentTree(vector<int>& nums) {
        int n = nums.size();
        root = buildST(nums, 0, n - 1);
    }

    void update(int i, int val) {
        update(root, i, val);
    }

    int sumRange(int i, int j) {
        return sumRange(root, i, j);
    }
private:
    SegmentTreeNode* root;
    SegmentTreeNode* buildST(vector<int>& nums, int s, int e) {
        if (s > e) return NULL;
        else {
            SegmentTreeNode* res = new SegmentTreeNode(s, e);
            if (s == e) res->sum = nums[s];
            else {
                int m = s + (e - s) / 2;
                res->left = buildST(nums, s, m);
                res->right = buildST(nums, m + 1, e);
                res->sum = res->left->sum + res->right->sum;
            }
            return res;
        }
    }
    void update(SegmentTreeNode* root, int i, int val) {
        if (root->s == root->e) root->sum = val;
        else {
            int m = root->s + (root->e - root->s) / 2;
            if (i <= m) update(root->left, i, val);
            else update(root->right, i, val);
            root->sum = root->left->sum + root->right->sum;
        }
    }
    int sumRange(SegmentTreeNode* root, int s, int e) {
        if (root->s == s && root->e == e) return root->sum;
        else {
            int m = root->s + (root->e - root->s) / 2;
            if (e <= m) return sumRange(root->left, s, e);
            else if (s >= m + 1) return sumRange(root->right, s, e);
            else return sumRange(root->left, s, m) + sumRange(root->right, m + 1, e);
        }
    }
};
2.Binary Indexed Treeï¼ŒBIT
class FenwickTree {
public:
    FenwickTree (vector<int> &nums) {
        BIT=vector<int>(nums.size()+1,0);
        data=nums;
        for(int i=1;i<=nums.size();i++){
            int lowbit=i&(-i);
            for(int j=i;j>i-lowbit;j--)
                BIT[i]+=nums[j-1];
        }
    }
    int lowbit(int x) {
        return x & -x;
    }
    FenwickTree (int n){
        BIT=vector<int>(n+1,0);
        data=vector<int>(n+1,0);
    }
    void add(int x, int val) {
        while (x <= BIT.size()) {
            BIT[x] += val;
            x += lowbit(x);
        }
    }
    void update(int i, int val) {
        int diff=val-data[i];
        data[i]=val;
        i++;
        while(i<BIT.size()){
            //During an update, we just care about the right links we follow
            BIT[i]+=diff;
            i=i+(i&(-i));
            //(i&(-i)) rightmost one
            //node find the parent in the right(node is of which parent's left)
            //1001->1010->1100->1000
        }
        
    }
    
    int sumRange(int i, int j) {
        return sum(j)-sum(i-1);
    }
    int sum(int index){
        //keep a variable ans initialized to 0. Follow the path from root to the index node.
        //Whenever we need to follow a right link, add the value of current node to ans. Once we reach the node, add that value too
        index++;
        int ret=0;
        while(index!=0){
            ret+=BIT[index];
            index=index&(index-1);
            // During a sum, we just care about the left links we follow.
            //right node find parent in the left(node is of which parent's right)
            //eg:1110->1100->1000->0
        }
        return ret;
    }
private:
    vector<int> BIT;
    vector<int> data;
};
